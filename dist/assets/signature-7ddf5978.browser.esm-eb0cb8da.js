var le=Object.defineProperty;var ce=(n,s,e)=>s in n?le(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e;var I=(n,s,e)=>(ce(n,typeof s!="symbol"?s+"":s,e),e);import{b2 as ue,b1 as X,b3 as fe,b4 as d,b5 as he,b6 as Z,aw as pe,a7 as q,b7 as T,a6 as z,K as N,b8 as M,b9 as _,l as de,p as me,B as L,aX as $,s as v,H as ee,z as ye,Q as ge,J as W,a5 as w,a8 as G,ba as be,aA as V,bb as we,ax as Y,I as Se,bc as F,bd as xe,be as U,bf as Te,bg as J,bh as Pe}from"./index-7323ac20.js";import{S as te,E as Ie}from"./assertEnabled-4d3448fa.browser.esm-d5e4f53c.js";import{N as D}from"./setErc20Allowance-5ac91ab4.browser.esm-6af33fd8.js";var Ae=function(s){for(var e=new X(s.length),t=0,r=s.length-1;t<=r;++t,--r)e[t]=s[r],e[r]=s[t];return e};const k=ue(Ae);var re={exports:{}};(function(n,s){(function(e,t){n.exports=t()})(fe,function(){function e(o,l){var i=l?"└":"├";return o?i+="─ ":i+="──┐",i}function t(o,l){var i=[];for(var c in o)o.hasOwnProperty(c)&&(l&&typeof o[c]=="function"||i.push(c));return i}function r(o,l,i,c,u,h,f){var p="",m=0,S,y,g=c.slice(0);if(g.push([l,i])&&c.length>0&&(c.forEach(function(b,x){x>0&&(p+=(b[1]?" ":"│")+"  "),!y&&b[0]===l&&(y=!0)}),p+=e(o,i)+o,u&&(typeof l!="object"||l instanceof Date)&&(p+=": "+l),y&&(p+=" (circular ref.)"),f(p)),!y&&typeof l=="object"){var P=t(l,h);P.forEach(function(b){S=++m===P.length,r(b,l[b],S,g,u,h,f)})}}var a={};return a.asLines=function(o,l,i,c){var u=typeof i!="function"?i:!1;r(".",o,!1,[],l,u,c||i)},a.asTree=function(o,l,i){var c="";return r(".",o,!1,[],l,i,function(u){c+=u+`
`}),c},a})})(re);var Ce=re.exports;class C{print(){C.print(this)}bufferIndexOf(s,e){if(arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1)return this.binarySearch(s,e,d.compare);const r=(a,o)=>a.equals(o);return this.linearSearch(s,e,r)}static binarySearch(s,e,t){let r=0,a=s.length-1;for(;r<=a;){const o=Math.floor((r+a)/2),l=t(s[o],e);if(l===0){for(let i=o-1;i>=0;i--)if(t(s[i],e)!==0)return i+1;return 0}else l<0?r=o+1:a=o-1}return-1}binarySearch(s,e,t){return C.binarySearch(s,e,t)}static linearSearch(s,e,t){for(let r=0;r<s.length;r++)if(t(s[r],e))return r;return-1}linearSearch(s,e,t){return C.linearSearch(s,e,t)}static bufferify(s){if(!d.isBuffer(s)){if(typeof s=="object"&&s.words)return d.from(s.toString(ve),"hex");if(C.isHexString(s))return d.from(s.replace(/^0x/,""),"hex");if(typeof s=="string")return d.from(s);if(typeof s=="bigint")return d.from(s.toString(16),"hex");if(s instanceof Uint8Array)return d.from(s.buffer);if(typeof s=="number"){let e=s.toString();return e.length%2&&(e=`0${e}`),d.from(e,"hex")}else if(ArrayBuffer.isView(s))return d.from(s.buffer,s.byteOffset,s.byteLength)}return s}bigNumberify(s){return C.bigNumberify(s)}static bigNumberify(s){if(typeof s=="bigint")return s;if(typeof s=="string")return s.startsWith("0x")&&C.isHexString(s)?BigInt("0x"+s.replace("0x","").toString()):BigInt(s);if(d.isBuffer(s))return BigInt("0x"+s.toString("hex"));if(s instanceof Uint8Array)return Be(s);if(typeof s=="number")return BigInt(s);throw new Error("cannot bigNumberify")}static isHexString(s){return typeof s=="string"&&/^(0x)?[0-9A-Fa-f]*$/.test(s)}static print(s){console.log(s.toString())}bufferToHex(s){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return C.bufferToHex(s,e)}static bufferToHex(s){return`${(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0)?"0x":""}${(s||d.alloc(0)).toString("hex")}`}bufferify(s){return C.bufferify(s)}bufferifyFn(s){return e=>{const t=s(e);if(d.isBuffer(t))return t;if(this.isHexString(t))return d.from(t.replace("0x",""),"hex");if(typeof t=="string")return d.from(t);if(typeof t=="bigint")return d.from(e.toString(16),"hex");if(ArrayBuffer.isView(t))return d.from(t.buffer,t.byteOffset,t.byteLength);const r=Le(e.toString("hex")),a=s(r),o=He(a);return d.from(o,"hex")}}isHexString(s){return C.isHexString(s)}log2(s){return s===1?0:1+this.log2(s/2|0)}zip(s,e){return s.map((t,r)=>[t,e[r]])}static hexZeroPad(s,e){return"0x"+s.replace("0x","").padStart(e,"0")}}var ke=C;function ve(n){const s=n.words,e=new ArrayBuffer(s.length*4),t=new Uint8Array(e);for(let r=0;r<s.length;r++)t[r*4]=s[r]>>24&255,t[r*4+1]=s[r]>>16&255,t[r*4+2]=s[r]>>8&255,t[r*4+3]=s[r]&255;return e}function Le(n){const s=new Uint8Array(n.length/2);for(let e=0;e<n.length;e+=2)s[e/2]=parseInt(n.substring(e,e+2),16);return s.buffer}function He(n){const s=new Uint8Array(n);return Array.from(s).map(e=>e.toString(16).padStart(2,"0")).join("")}function Be(n){const s=Array.from(n).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt(`0x${s}`)}class H extends ke{constructor(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};super();I(this,"duplicateOdd",!1);I(this,"concatenator",d.concat);I(this,"hashLeaves",!1);I(this,"isBitcoinTree",!1);I(this,"leaves",[]);I(this,"layers",[]);I(this,"sortLeaves",!1);I(this,"sortPairs",!1);I(this,"sort",!1);I(this,"fillDefaultHash",null);I(this,"complete",!1);if(r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if(typeof r.fillDefaultHash=="function")this.fillDefaultHash=r.fillDefaultHash;else if(d.isBuffer(r.fillDefaultHash)||typeof r.fillDefaultHash=="string")this.fillDefaultHash=(a,o)=>r.fillDefaultHash;else throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:((e=this.fillDefaultHash)==null?void 0:e.toString())??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&t===1&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=r){this.layers[t].push(...e.slice(r));break}else if(a+1===e.length&&e.length%2===1){const u=e[e.length-1];let h=u;if(this.isBitcoinTree){h=this.hashFn(this.concatenator([k(u),k(u)])),h=k(this.hashFn(h)),this.layers[t].push(h);continue}else if(!this.duplicateOdd){this.layers[t].push(e[a]);continue}}const o=e[a],l=a+1===e.length?o:e[a+1];let i=null;this.isBitcoinTree?i=[k(o),k(l)]:i=[o,l],this.sortPairs&&i.sort(d.compare);let c=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(c=k(this.hashFn(c))),this.layers[t].push(c)}e=this.layers[t]}}addLeaf(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(d.compare))),this.leaves.filter(t=>this.bufferIndexOf(e,t,this.sortLeaves)!==-1)):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?d.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(t=>H.bufferToHex(t)),null,2)}static unmarshalLeaves(e){let t=null;if(typeof e=="string")t=JSON.parse(e);else if(e instanceof Object)t=e;else throw new Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(H.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(r=>this.bufferToHex(r))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((t,r)=>(Array.isArray(r)?t.unshift(...r):t.unshift(r),t),[]);return e.unshift(d.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return this.layers.length===0?d.from([]):this.layers[this.layers.length-1][0]||d.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let a=0;a<this.leaves.length;a++)d.compare(e,this.leaves[a])===0&&(t=a)}if(t<=-1)return[];for(let a=0;a<this.layers.length;a++){const o=this.layers[a],l=t%2,i=l?t-1:this.isBitcoinTree&&t===o.length-1&&a<this.layers.length-1?t:t+1;i<o.length&&r.push({position:l?"left":"right",data:o[i]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(r=>this.bufferToHex(r.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,a){const o=t%2;if(e===-1){o||a.push([...r].reverse());return}if(t>=this.layers[e].length)return;const l=this.layers[e],i=o?t-1:t+1;let c=!1;i<l.length&&(c=!0,r.push({position:o?"left":"right",data:l[i]}));const u=t*2,h=t*2+1;this.getProofsDFS(e-1,u,r,a),this.getProofsDFS(e-1,h,r,a),c&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(r=>[r.position==="left"?0:1,this.bufferToHex(r.data)])}getProofIndices(e,t){const r=2**t;let a=new Set;for(const u of e){let h=r+u;for(;h>1;)a.add(h^1),h=h/2|0}const o=e.map(u=>r+u),l=Array.from(a).sort((u,h)=>u-h).reverse();a=o.concat(l);const i=new Set,c=[];for(let u of a)if(!i.has(u))for(c.push(u);u>1&&(i.add(u),!!i.has(u^1));)u=u/2|0;return c.filter(u=>!e.includes(u-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),a=[];for(let i=0;i<r;i++)t%2!==0&&a.push({index:i,leavesCount:t}),t=Math.ceil(t/2);const o=[];let l=e;for(let i=0;i<r;i++){let u=l.map(f=>f%2===0?f+1:f-1).filter(f=>!l.includes(f));const h=a.find(f=>{let{index:p}=f;return p===i});h&&l.includes(h.leavesCount-1)&&(u=u.slice(0,-1)),o.push(u),l=[...new Set(l.map(f=>f%2===0?f/2:f%2===0?(f+1)/2:(f-1)/2))]}return o}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let a=t;this.sortPairs&&(a=a.sort(d.compare));let o=a.map(u=>this.bufferIndexOf(this.leaves,u,this.sortLeaves)).sort((u,h)=>u===h?0:u>h?1:-1);if(!o.every(u=>u!==-1))throw new Error("Element does not exist in Merkle tree");const l=[],i=[];let c=[];for(let u=0;u<this.layers.length;u++){const h=this.layers[u];for(let f=0;f<o.length;f++){const p=o[f],m=this.getPairNode(h,p);l.push(h[p]),m&&i.push(m),c.push(p/2|0)}o=c.filter((f,p,m)=>m.indexOf(f)===p),c=[]}return i.filter(u=>!l.includes(u))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(a=>e[a])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],a=t;for(const o of e){const l=[];for(const c of a){if(c%2===0){const h=c+1;if(!a.includes(h)&&o[h]){l.push(o[h]);continue}}const u=c-1;if(!a.includes(u)&&o[u]){l.push(o[u]);continue}}r=r.concat(l);const i=new Set;for(const c of a){if(c%2===0){i.add(c/2);continue}if(c%2===0){i.add((c+1)/2);continue}i.add((c-1)/2)}a=Array.from(i)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(r=>this.bufferToHex(r))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(e.every(Number.isInteger)?r=[...e].sort((i,c)=>i===c?0:i>c?1:-1):r=e.map(i=>this.bufferIndexOf(this.leaves,i,this.sortLeaves)).sort((i,c)=>i===c?0:i>c?1:-1),!r.every(i=>i!==-1))throw new Error("Element does not exist in Merkle tree");const a=t.map(i=>this.bufferify(i)),o=[],l=[];for(let i=0;i<this.layers.length;i++){const c=this.layers[i];r=r.reduce((u,h)=>{if(!o.includes(c[h])){const p=this.getPairNode(c,h),m=a.includes(c[h])||a.includes(p);p&&l.push(!m),o.push(c[h]),o.push(p)}return u.push(h/2|0),u},[])}return l}verify(e,t,r){let a=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let o=0;o<e.length;o++){const l=e[o];let i=null,c=null;if(typeof l=="string")i=this.bufferify(l),c=!0;else if(Array.isArray(l))c=l[0]===0,i=this.bufferify(l[1]);else if(d.isBuffer(l))i=l,c=!0;else if(l instanceof Object)i=this.bufferify(l.data),c=l.position==="left";else throw new Error("Expected node to be of type string or object");const u=[];this.isBitcoinTree?(u.push(k(a)),u[c?"unshift":"push"](k(i)),a=this.hashFn(this.concatenator(u)),a=k(this.hashFn(a))):this.sortPairs?d.compare(a,i)===-1?(u.push(a,i),a=this.hashFn(this.concatenator(u))):(u.push(i,a),a=this.hashFn(this.concatenator(u))):(u.push(a),u[c?"unshift":"push"](i),a=this.hashFn(this.concatenator(u)))}return d.compare(a,r)===0}verifyMultiProof(e,t,r,a,o){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,a,o);const i=Math.ceil(Math.log2(a));e=this.bufferify(e),r=r.map(f=>this.bufferify(f)),o=o.map(f=>this.bufferify(f));const c={};for(const[f,p]of this.zip(t,r))c[2**i+f]=p;for(const[f,p]of this.zip(this.getProofIndices(t,i),o))c[f]=p;let u=Object.keys(c).map(f=>Number(f)).sort((f,p)=>f-p);u=u.slice(0,u.length-1);let h=0;for(;h<u.length;){const f=u[h];if(f>=2&&{}.hasOwnProperty.call(c,f^1)){let p=[c[f-f%2],c[f-f%2+1]];this.sortPairs&&(p=p.sort(d.compare));const m=p[1]?this.hashFn(this.concatenator(p)):p[0];c[f/2|0]=m,u.push(f/2|0)}h+=1}return!t.length||{}.hasOwnProperty.call(c,1)&&c[1].equals(e)}verifyMultiProofWithFlags(e,t,r,a){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const o=t.length,l=a.length,i=[];let c=0,u=0,h=0;for(let f=0;f<l;f++){const p=a[f]?c<o?t[c++]:i[u++]:r[h++],m=c<o?t[c++]:i[u++],S=[p,m].sort(d.compare);i[f]=this.hashFn(this.concatenator(S))}return d.compare(i[l-1],e)===0}verifyMultiProofForUnevenTree(e,t,r,a,o){e=this.bufferify(e),r=r.map(i=>this.bufferify(i)),o=o.map(i=>this.bufferify(i));const l=this.calculateRootForUnevenTree(t,r,a,o);return e.equals(l)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(r=>r.map(a=>this.bufferToHex(a,!1))),t=[];for(let r=0;r<e.length;r++){const a=[];for(let o=0;o<e[r].length;o++){const l={[e[r][o]]:null};if(t.length){l[e[r][o]]={};const i=t.shift(),c=Object.keys(i)[0];if(l[e[r][o]][c]=i[c],t.length){const u=t.shift(),h=Object.keys(u)[0];l[e[r][o]][h]=u[h]}}a.push(l)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return Ce.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(e==null?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,a){const o=this.zip(e,t).sort((f,p)=>{let[m]=f,[S]=p;return m-S}),l=o.map(f=>{let[p]=f;return p}),i=this.getProofIndicesForUnevenTree(l,r);let c=0;const u=[];for(let f=0;f<i.length;f++){const p=i[f],m=c;c+=p.length,u[f]=this.zip(p,a.slice(m,c))}const h=[o];for(let f=0;f<u.length;f++){const p=u[f].concat(h[f]).sort((g,P)=>{let[b]=g,[x]=P;return b-x}).map(g=>{let[,P]=g;return P}),m=h[f].map(g=>{let[P]=g;return P}),S=[...new Set(m.map(g=>g%2===0?g/2:g%2===0?(g+1)/2:(g-1)/2))],y=[];for(let g=0;g<S.length;g++){const P=S[g],b=p[g*2],x=p[g*2+1],O=x?this.hashFn(this.concatenator([b,x])):b;y.push([P,O])}h.push(y)}return h[h.length-1][0][1]}}function Ye(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerTransaction:n.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims||0}}function Xe(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerWallet:n.maxClaimablePerWallet,metadata:n.metadata||""}}function B(n,s){return n==="unlimited"?N:M(n,s)}async function se(n){const e=Array.from({length:Math.ceil(n.length/25e3)},(a,o)=>n.slice(o*25e3,o*25e3+25e3)),t=[],r=await Promise.all(e.map(a=>J.parseAsync(a)));for(const a of r)t.push(...a);return t}const Oe=2;let j=function(n){return n[n.V1=1]="V1",n[n.V2=2]="V2",n}({});class A{constructor(s,e,t,r,a){this.storage=s,this.shardNybbles=r,this.baseUri=e,this.originalEntriesUri=t,this.tokenDecimals=a,this.shards={},this.trees={}}static async fromUri(s,e){try{const t=await e.downloadJSON(s);if(t.isShardedMerkleTree)return A.fromShardedMerkleTreeInfo(t,e)}catch{return}}static async fromShardedMerkleTreeInfo(s,e){return new A(e,s.baseUri,s.originalEntriesUri,s.shardNybbles,s.tokenDecimals)}static hashEntry(s,e,t,r){switch(r){case j.V1:return Y(["address","uint256"],[s.address,B(s.maxClaimable,e)]);case j.V2:return Y(["address","uint256","uint256","address"],[s.address,B(s.maxClaimable,e),B(s.price||"unlimited",t),s.currencyAddress||v])}}static async fetchAndCacheDecimals(s,e,t){if(!t)return 18;let r=s[t];return r===void 0&&(r=(await Se(e,t)).decimals,s[t]=r),r}static async buildAndUpload(s,e,t,r,a){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:Oe;const l=await se(s),i={};for(const b of l){const x=b.address.slice(2,2+o).toLowerCase();i[x]===void 0&&(i[x]=[]),i[x].push(b)}const c={},u=await Promise.all(Object.entries(i).map(async b=>{let[x,O]=b;return[x,new H(await Promise.all(O.map(async R=>{const oe=await A.fetchAndCacheDecimals(c,t,R.currencyAddress);return A.hashEntry(R,e,oe,a)})),F,{sort:!0}).getHexRoot()]})),h=Object.fromEntries(u),f=new H(Object.values(h),F,{sort:!0}),p=[];for(const[b,x]of Object.entries(i)){const O={proofs:f.getProof(h[b]).map(R=>"0x"+R.data.toString("hex")),entries:x};p.push({data:JSON.stringify(O),name:`${b}.json`})}const m=await r.uploadBatch(p),S=m[0].slice(0,m[0].lastIndexOf("/")),y=await r.upload(l),g={merkleRoot:f.getHexRoot(),baseUri:S,originalEntriesUri:y,shardNybbles:o,tokenDecimals:e,isShardedMerkleTree:!0},P=await r.upload(g);return{shardedMerkleInfo:g,uri:P}}async getProof(s,e,t){const r=s.slice(2,2+this.shardNybbles).toLowerCase();let a=this.shards[r];const o={};if(a===void 0)try{const h=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;a=this.shards[r]=await this.storage.downloadJSON(`${h}${r}.json`);const f=await Promise.all(a.entries.map(async p=>{const m=await A.fetchAndCacheDecimals(o,e,p.currencyAddress);return A.hashEntry(p,this.tokenDecimals,m,t)}));this.trees[r]=new H(f,F,{sort:!0})}catch{return null}const l=a.entries.find(h=>h.address.toLowerCase()===s.toLowerCase());if(!l)return null;const i=await A.fetchAndCacheDecimals(o,e,l.currencyAddress),c=A.hashEntry(l,this.tokenDecimals,i,t),u=this.trees[r].getProof(c).map(h=>"0x"+h.data.toString("hex"));return xe.parseAsync({...l,proof:u.concat(a.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(s){return console.warn("Could not fetch original snapshot entries",s),[]}}}async function Ne(n,s,e,t,r,a){if(!e)return null;const o=e[s];if(o){const l=await r.downloadJSON(o);if(l.isShardedMerkleTree&&l.merkleRoot===s)return await(await A.fromShardedMerkleTreeInfo(l,r)).getProof(n,t,a);const i=await _.parseAsync(l);if(s===i.merkleRoot)return i.claims.find(c=>c.address.toLowerCase()===n.toLowerCase())||null}return null}function _e(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims}}function et(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:n.metadata}}async function Re(n,s,e,t,r){const a=n.getSigner(),o=n.getProvider(),l=(await de(()=>import("./index-7323ac20.js").then(p=>p.dE),["assets/index-7323ac20.js","assets/index-c7a68507.css"])).default,i=new me(a||o,s,l,n.options,n.storage),c=await n.getSignerAddress(),u=n.address,h=await i.read("allowance",[c,u]),f=L.from(e).mul(L.from(t)).div(M("1",r));h.lt(f)&&await i.sendTransaction("approve",[u,h.add(f)])}async function tt(n,s,e,t,r,a,o,l,i){let c=B(e.maxClaimablePerWallet,r),u=[$([0],32)],h=e.price,f=e.currencyAddress;try{if(!e.merkleRootHash.toString().startsWith(v)){const y=await Ne(n,e.merkleRootHash.toString(),await t(),a.getProvider(),o,i);if(y)u=y.proof,c=y.maxClaimable==="unlimited"?N:M(y.maxClaimable,r),h=y.price===void 0||y.price==="unlimited"?N:await ee(a.getProvider(),y.price,y.currencyAddress||v),f=y.currencyAddress||v;else if(i===j.V1)throw new Error("No claim found for this address")}}catch(y){if((y==null?void 0:y.message)==="No claim found for this address")throw y;console.warn("failed to check claim condition merkle root hash, continuing anyways",y)}const p=await a.getCallOverrides()||{},m=h.toString()!==N.toString()?h:e.price,S=f!==v?f:e.currencyAddress;return m.gt(0)&&(ye(S)?p.value=L.from(m).mul(s).div(M("1",r)):l&&await Re(a,S,m,s,r)),{overrides:p,proofs:u,maxClaimable:c,price:m,currencyAddress:S,priceInProof:h,currencyAddressInProof:f}}const Ee=(()=>w.object({name:w.string(),symbol:w.string(),decimals:w.number()}))(),Me=(()=>Ee.extend({value:T,displayValue:w.string()}))(),Ue=(()=>w.object({name:w.string().optional()}).catchall(w.unknown()))(),Q=(()=>w.object({startTime:te,currencyAddress:w.string().default(V),price:q.default(0),maxClaimableSupply:U,maxClaimablePerWallet:U,waitInSeconds:z.default(0),merkleRootHash:Te.default($([0],32)),snapshot:w.optional(J).nullable(),metadata:Ue.optional()}))(),De=(()=>w.array(Q))(),ne=(()=>Q.extend({availableSupply:U,currentMintSupply:U,currencyMetadata:Me.default({value:L.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:T,waitInSeconds:T,startTime:T.transform(n=>new Date(n.toNumber()*1e3)),snapshot:J.optional().nullable()}))();async function Fe(n,s,e,t,r){const a=await se(n),o=a.map(c=>c.address);if(new Set(o).size<o.length)throw new Pe;const i=await A.buildAndUpload(a,s,e,t,r);return{merkleRoot:i.shardedMerkleInfo.merkleRoot,snapshotUri:i.uri}}function We(n,s){const e=L.from(n),t=L.from(s);return e.eq(t)?0:e.gt(t)?1:-1}async function je(n,s,e,t,r){const a=[];return{inputsWithSnapshots:await Promise.all(n.map(async l=>{if(l.snapshot&&l.snapshot.length>0){const i=await Fe(l.snapshot,s,e,t,r);a.push(i),l.merkleRootHash=i.merkleRoot}else l.merkleRootHash=$([0],32);return l})),snapshotInfos:a}}async function qe(n,s,e,t){const r=n.currencyAddress===v?V:n.currencyAddress,a=B(n.maxClaimableSupply,s),o=B(n.maxClaimablePerWallet,s);let l;return n.metadata&&(typeof n.metadata=="string"?l=n.metadata:l=await t.upload(n.metadata)),{startTimestamp:n.startTime,maxClaimableSupply:a,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await ee(e,n.price,r),currency:r,merkleRoot:n.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:n.waitInSeconds||0,metadata:l}}async function rt(n,s,e,t,r){const{inputsWithSnapshots:a,snapshotInfos:o}=await je(n,s,e,t,r),l=await De.parseAsync(a),i=(await Promise.all(l.map(c=>qe(c,s,e,t)))).sort((c,u)=>We(c.startTimestamp,u.startTimestamp));return{snapshotInfos:o,sortedConditions:i}}async function ze(n,s,e){if(!s)return null;const t=s[n];if(t){const r=await e.downloadJSON(t);if(r.isShardedMerkleTree&&r.merkleRoot===n){const a=await A.fromUri(t,e);return(a==null?void 0:a.getAllEntries())||null}else{const a=await _.parseAsync(r);if(n===a.merkleRoot)return a.claims.map(o=>({address:o.address,maxClaimable:o.maxClaimable,price:o.price,currencyAddress:o.currencyAddress}))}}return null}function E(n,s){return n.toString()===N.toString()?"unlimited":W(n,s)}async function st(n,s,e,t,r,a){var f;const o=await ge(e,n.currency,n.pricePerToken),l=E(n.maxClaimableSupply,s),i=E(n.maxClaimablePerWallet,s),c=E(L.from(n.maxClaimableSupply).sub(n.supplyClaimed),s),u=E(n.supplyClaimed,s);let h;return n.metadata&&(h=await r.downloadJSON(n.metadata)),ne.parseAsync({startTime:n.startTimestamp,maxClaimableSupply:l,maxClaimablePerWallet:i,currentMintSupply:u,availableSupply:c,waitInSeconds:(f=n.waitTimeInSecondsBetweenClaims)==null?void 0:f.toString(),price:L.from(n.pricePerToken),currency:n.currency,currencyAddress:n.currency,currencyMetadata:o,merkleRootHash:n.merkleRoot,snapshot:a?await ze(n.merkleRoot,t,r):void 0,metadata:h})}async function nt(n,s,e){if(n>=e.length)throw Error(`Index out of bounds - got index: ${n} with ${e.length} conditions`);const t=e[n].currencyMetadata.decimals,r=e[n].price,a=W(r,t),o=await Q.parseAsync({...e[n],price:a,...s}),l=await ne.parseAsync({...o,price:r});return e.map((i,c)=>{let u;c===n?u=l:u=i;const h=W(u.price,t);return{...u,price:h}})}let at=function(n){return n.NotEnoughSupply="There is not enough supply to claim.",n.AddressNotAllowed="This address is not on the allowlist.",n.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",n.ClaimPhaseNotStarted="Claim phase has not started yet.",n.AlreadyClaimed="You have already claimed the token.",n.WrongPriceOrCurrency="Incorrect price or currency.",n.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",n.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",n.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",n.NoClaimConditionSet="There is no claim condition set.",n.NoWallet="No wallet connected.",n.Unknown="No claim conditions found.",n}({});function $e(n){if(n===void 0){const s=X.alloc(16);return he({},s),Z(pe(s.toString("hex")))}else return Z(n)}const ae=(()=>w.object({to:G.refine(n=>n.toLowerCase()!==v,{message:"Cannot create payload to mint to zero address"}),price:q.default(0),currencyAddress:be.default(V),mintStartTime:te,mintEndTime:Ie,uid:w.string().optional().transform(n=>$e(n)),primarySaleRecipient:G.default(v)}))(),Ve=(()=>ae.extend({quantity:q}))(),it=(()=>Ve.extend({mintStartTime:T,mintEndTime:T}))(),K=(()=>ae.extend({metadata:D,royaltyRecipient:w.string().default(v),royaltyBps:we.default(0)}))(),ie=(()=>K.extend({metadata:D.default(""),uri:w.string(),royaltyBps:T,mintStartTime:T,mintEndTime:T}))(),Je=(()=>K.extend({metadata:D.default(""),quantity:z}))(),ot=(()=>Je.extend({tokenId:z}))(),lt=(()=>ie.extend({tokenId:T,quantity:T}))(),ct=(()=>K.extend({metadata:D.default(""),quantity:T.default(1)}))(),ut=(()=>ie.extend({quantity:T.default(1)}))(),ft=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ht=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],dt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];export{ae as B,at as C,pt as M,ot as S,Re as a,lt as b,B as c,Ye as d,Xe as e,Ne as f,tt as g,j as h,ct as i,ut as j,ht as k,_e as l,dt as m,et as n,Ve as o,rt as p,it as q,ft as r,$e as s,st as t,nt as u};
